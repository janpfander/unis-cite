---
title: "Volunteer Report Cité-Unis"
shorttitle: "Cité-Unis"
author:
  - name: Jan Pfänder
    corresponding: true
    email: janlukas.pfaender@gmail.com
    affiliations: Paris
    
abstract: "This report analyzes survey data for four different cohorts of Cité-Unis volunteers who did their service civique (2020-2024)."

mask: true

format:
  html: default
  apaquarto-docx: default  
  apaquarto-pdf:
    # Can be jou (journal), man (manuscript), stu (student), or doc (document)
    documentmode: doc

always_allow_html: true
---

```{r}
library(tidyverse)
library(readxl)
library(labelled) # for extracting labels from labelled data
library(sjlabelled)
library(ggalluvial)  # For alluvial (sankey-style) plots
library(sf)         # For GIS magic
library(rmapshaper) # simplify maps (so that they're less complex and take less time to handle)
library(wesanderson)
library(kableExtra)
library(broom)
library(gtsummary)
library(flextable)
library(gt)
library(ggpubr)
library(DescTools)
#library(brms)
```

```{r functions}
# load functions
source("functions/functions.R")
```

```{r}
# read data
load("data/cleaned_promo_combined.RData")
combined <- combined_data

# read map
map <- readRDS("data/map.rds")

# read codebook
codebook <- read_csv("data/codebook.csv") |> 
  # display answer options more nicely
  mutate(answer_options = str_replace_all(answer_options, "\\n", "; ")) 

# define by hand demographic variables (for tables and computations)
demographic_variables <- c(
  "type_volontaire", "sexe",
  "refugie", "age_categorie", "zone_residence",
  "niveau_etudes", "handicap_auto_declare", "handicap_administratif",
  "duree_prevue_sc_mois", "duree_reelle_sc_mois", "rupture"
)

# define other demographic variables that are not reported in tables, but used for subsetting data sets
demographic_variables_not_reported <- c("id_jeune", "region", "site", "type_volontaire", "decrocheur", "nationalite", "neets", "programme_1", "programme_2", "rupture_negative", "rupture_valence")
```

# Introduction

This report analyzes survey data for four different cohorts of Cité Unis volunteers who did their service civique in France between 2020 and 2024.

@sec-who provides analyses as to who are the volunteers. In @sec-within-change, we look at how the service civique has changed the volunteers' attitudes and views? We then look at several outcomes of interest in detail, namely whether volunteers end their contract early (@sec-rupture), how satisfied they are (@sec-satisfaction), and how confident they are about their future? (@sec-perception-avenir). For these outcomes, we analyze whether there are trends across the different cohorts, and which demographic variables predict them. In @sec-programs we investigate differences between different programs offered by Cité Unis. The report ends with a brief conclusion on methodological notes for future questionnaires. 

For these analyses, we rely on questionnaires collected by Cité Unis for four different cohorts of volunteers who did their service civique for a year (2020-2021; 2021-2022; 2022-2023; 2023-2024). These questionnaires are very extensive. For the present analyses, we selected a subset of key questions (a full list can be found in the [codebook](codebook.qmd))^[Note that, in the process of writing this report, this selection of variables was based only on the questionnaire of the first cohort (2020/21). As a result, potentially interesting variables that only appear in later questionnaires will not appear here.]. 

Before diving into the results, a note on caution in interpreting the results presented in is report: Whenever we speak of "predictions", that simply means statistical associations---mere observations of differences between groups. This report does **not** provide any evidence that would warrant causal conclusions---answers as to **why** we observe these differences. 

Because the data underlying this report is observational and---for most of it---does not allow to track opinion change (because most questions have only been asked once per cohort), the main objective of this report is not to provide specific and definitive answers. Instead, the aim is to allow Cité Unis to identify interesting questions. The numeric results presented here can act as pointers, but are not problem diagnoses. They always need to be accompanied by qualitative assessments of *why* we observe certain differences, and what could or could not be done about them. 

This report is meant to inform by figures: the text passages do not discuss all the results from the figures. The text is mostly intended to provide guidance---to illustrate how to interpret the figures. The examples for these illustrations are mostly picked at random.

# Who are the volunteers ? {#sec-who}

In this section, we review some demographic variables in detail. An extensive summary table with sample demographics across the different cohorts can be found in [Tables](tables.qmd). 

## Geographic location

```{r descriptives-demographics}
# get average participants per year for departments
participants_per_year_department <- map |> 
  st_drop_geometry() |> 
  group_by(NOM) |> 
  summarise(n = round(mean(n, na.rm = TRUE))) |> 
  arrange(desc(n))

n_departments <- sum(!is.na(participants_per_year_department$n))

# trend data by departments
trend_department <- map |> 
  st_drop_geometry() |> 
  pivot_wider(names_from = promo, 
              values_from = n) |> 
  mutate(trend = `23-24` - `20-21`) |> 
  summarize(
    mean_trend = mean(trend, na.rm = TRUE), 
    trend_positive = sum(trend > 0, na.rm = TRUE), 
    trend_negative = sum(trend < 0, na.rm = TRUE)
  ) |> 
  rounded_numbers()

# average trends for promo
n_per_promo <- combined |>
  group_by(promo) |>
  summarise(n = n_distinct(id_jeune)) |>
  # Extract starting year of each promo
  mutate(year = as.numeric(str_sub(promo, 1, 2))) |>  
  arrange(year) 
  
trend_per_year <- lm(n ~ year, data = n_per_promo) |> 
  tidy() %>%
  split(.$term)

```

Volunteers came from `r n_departments` different departments (see @fig-map-repartition). On average, across the different cohorts, most volunteers came from `r participants_per_year_department$NOM[1]` (n = `r participants_per_year_department$n[1]`), followed by `r participants_per_year_department$NOM[2]` (n = `r participants_per_year_department$n[2]`) and `r participants_per_year_department$NOM[3]` (n = `r participants_per_year_department$n[3]`). 

Overall, there has been a steady increase in volunteers, from `r first(n_per_promo$n)` in `r first(n_per_promo$promo)` to `r last(n_per_promo$n)` in `r last(n_per_promo$promo)`, and an average increase of `r trend_per_year$year$estimate` per year. Since the `r first(n_per_promo$promo)` cohort, each departement has on average increased by `r trend_department$mean_trend`. There were `r trend_department$trend_positive` departements who saw an increase, and `r trend_department$trend_negative` who saw a decrease (see @fig-map-trend). For details on the trend of each departement, see [Tables](tables.qmd). 

```{r}
#| label: fig-map-repartition
#| fig-cap: Répartition des volontaires en France à travers le temps. 

pal <- wes_palette("Zissou1", 100, type = "continuous")

ggplot() +
  geom_sf(data = map, aes(fill = n)) +
  scale_fill_gradientn(colours = pal, na.value = "white") + 
  theme_minimal() +
  coord_sf(datum = NA) +  # removes the coordinate axes and graticules
  labs(
    title = "Répartition des volontaires en France",
    fill = "Nombre de volontaires"
  ) +
  facet_wrap(~promo)
```

```{r}
#| label: fig-map-trend
#| fig-cap: Evolution de recrutement pour la promo de 2023-24 par rapport à 2020-21. 
#| 
# make a trend map of volunteers
map |> 
  pivot_wider(names_from = promo, 
              values_from = n) |> 
  mutate(trend = `23-24` - `20-21`) |> 
ggplot() +
  geom_sf(aes(fill = trend)) +
  scale_fill_gradient2(low = "#2C7BB6", mid = "grey", high = "#D7191C",
                           midpoint = 0, na.value = "white") +
  theme_minimal() +
  coord_sf(datum = NA) +  # removes the coordinate axes and graticules
  labs(
    title = "Difference Récrutement entre 2023 et 2020",
    fill = "Nombre de volontaires"
  )
```

## Age

As shown in @fig-age, across all promos, the majority of volunteers is between 18 and 20 years old. The share of the age group of 16-17 has been increasing rapily, doubling the percentage points from 13% in 2020 to 24% in 2024.

```{r}
#| label: fig-age
#| fig-cap: "Number of volunteers per age group, within the different promos. Note that, in the percentage plot, the percentages are relative to all volunteers from the respective promo."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

# ABSOLUTE NUMBERS

# Prepare data: Count unique participants per source
age_data <- combined |> 
  group_by(promo, age_categorie) |> 
  summarise(n_participants = n_distinct(id_jeune)) |> 
  group_by(promo) |> 
  mutate(share = n_participants/sum(n_participants)) |> 
  ungroup()


# Plot attrition trend across sources
ggplot(age_data, aes(x = age_categorie, y = n_participants)) +
geom_col() +
  geom_text(aes(label = n_participants), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  theme_minimal() +
  labs(
    title = "Age groups",
    x = "Age group",
    y = "Number of Participants"
  ) + 
  plot_theme +
  facet_wrap(~promo)

# PERCENTAGES

color <- wes_palette("BottleRocket2")[3]

ggplot(age_data,
       aes(x = age_categorie, y = share)) +
  geom_col(fill = color) +
  geom_text(aes(label = paste0(round(share*100, 1), "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  labs(
    title = "Age groups",
    x = "Age group",
    y = "Share of participants"
  ) +
  plot_theme +
  facet_wrap(~promo)
```

## Education

@fig-education shows that volunteers with a "Bac + 3 et plus" are relatively rare. The share of volunteers with a "Bac à Bac + 2" has been constantly decreasing, from 48% in 2020-21 to 40% in 2023-24. By contrast, volunteers "Infra-bac", have been increasing from 32% in 2020-21 to 43% in 2023-24. 

```{r}
#| label: fig-education
#| fig-cap: "Number of volunteers per education level, within the different promos. Note that in the percentage plot, the percentages are relative to all volunteers from the respective promo."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

# ABSOLUTE NUMBERS

# Prepare data: Count unique participants per source
education_data <- combined |> 
  group_by(promo, niveau_etudes) |> 
  summarise(n_participants = n_distinct(id_jeune)) |> 
  group_by(promo) |> 
  mutate(share = n_participants/sum(n_participants)) |> 
  ungroup()


# Plot attrition trend across sources
ggplot(education_data, aes(x = niveau_etudes, y = n_participants)) +
geom_col() +
  geom_text(aes(label = n_participants), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  theme_minimal() +
  labs(
    title = "Education",
    x = "Level of education",
    y = "Number of Participants"
  ) + 
  plot_theme +
  facet_wrap(~promo)

# PERCENTAGES

color <- wes_palette("BottleRocket2")[4]

ggplot(education_data,
       aes(x = niveau_etudes, y = share)) +
  geom_col(fill = color) +
  geom_text(aes(label = paste0(round(share*100, 1), "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  labs(
    title = "Education",
    x = "Level of education",
    y = "Share of participants"
  ) +
  plot_theme +
  facet_wrap(~promo)
```

## Sex

There is a stable difference regarding sex, with more women (~60%) being volunteers than men (@fig-sex). 

```{r}
#| label: fig-sex
#| fig-cap: "Number of male and female volunteers, within the different promos. Note that in the percentage plot, the percentages are relative to all volunteers from the respective promo."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

# ABSOLUTE NUMBERS

# Prepare data: Count unique participants per source
sex_data <- combined |> 
  group_by(promo, sexe) |> 
  summarise(n_participants = n_distinct(id_jeune)) |> 
  group_by(promo) |> 
  mutate(share = n_participants/sum(n_participants)) |> 
  ungroup()


# Plot attrition trend across sources
ggplot(sex_data, aes(x = sexe, y = n_participants)) +
geom_col() +
  geom_text(aes(label = n_participants), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = wes_palette("Darjeeling1")[c(3, 5)]) +
  theme_minimal() +
  labs(
    title = "Sex",
    x = "Sex",
    y = "Number of Participants"
  ) + 
  guides(fill = FALSE) +
  plot_theme +
  facet_wrap(~promo)

# PERCENTAGES
ggplot(sex_data,
       aes(x = sexe, y = share, fill = sexe)) +
  geom_col() +
  geom_text(aes(label = paste0(round(share*100, 1), "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = wes_palette("Darjeeling1")[c(3, 5)]) +
  labs(
    title = "Sex",
    x = "Sex",
    y = "Share of participants"
  ) +
  guides(fill = FALSE) +
  plot_theme +
  facet_wrap(~promo)
```

# How have volunteers changed their attitudes? {#sec-within-change}

In the selection of variables made for this report, there are only two questions that volunteers of the same promo have been asked at different time points: 

1. "Avez-vous voté lors des dernières élections (locales ou nationales) ?" (@sec-vote)

2. "En général, pensez-vous que votre action individuelle peut contribuer à changer la société ?" (@sec-individual-action). 

Before we turn to these two questions, we will look at attrition.

## Attrition

The term attrition refers to volunteers dropping out of the surveys over time. Attrition can can have many causes. Here we distinguish between two explanations: ruptures, i.e. volonteers ending their service civique early (@sec-rupture) and survey fatigue, i.e. volunteers who continue their service civique but do not fill out the questionnaires (@fig-attrition-norupture). 

@fig-attrition shows attrition generally, while @fig-attrition-norupture excludes ruptures, thereby giving an estimate of survey fatigue. This latter figure shows that survey fatigue is an issue, but also suggests that there is a slightly positive trend towards reduced survey fatigue: more and more volunteers seem to answering the questionnaires at least for the first two questionnaires (q1 and q2), but less so for the third questionnaire (q3). 

```{r}
#| label: fig-attrition
#| fig-cap: "Number of volunteers per survey time point. Volunteers who appear under 'q0' have participated in the program but have not even filled out the first questionnaire (q1). Note that in the percentage plot, the percentages are relative to all volunteers from the respective promo. This plot **includes** ruptures."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

# ABSOLUTE NUMBERS

# Prepare data: Count unique participants per source
attrition_data <- combined |> 
  group_by(promo, source) |> 
  summarise(n_participants = n_distinct(id_jeune)) |> 
  # remove the programmes (since it is not a survey time point)
  filter(source != "programmes") 


# Plot attrition trend across sources
ggplot(attrition_data, aes(x = source, y = n_participants)) +
geom_col() +
  geom_text(aes(label = n_participants), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  theme_minimal() +
  labs(
    title = "Attrition",
    x = "Time Point",
    y = "Number of Participants"
  ) + 
  plot_theme +
  facet_wrap(~promo)

# PERCENTAGES

# Step 1: Get baseline (q0 + q1) counts per promo
baseline_counts <- combined |>
  filter(source == "q0" | source == "q1") |>
  group_by(promo) |>
  summarise(baseline_n = n_distinct(id_jeune), .groups = "drop")

# Step 2: Count participants per source and promo
attrition_percent <- combined |>
  group_by(promo, source) |>
  summarise(n_participants = n_distinct(id_jeune), .groups = "drop") |>
  filter(source != "programmes") |> 
  left_join(baseline_counts, by = "promo") |>
  mutate(percent = n_participants / baseline_n)

# Step 3: Plot percentages relative to q0 and q1 

color <- wes_palette("Moonrise2")[1]

ggplot(attrition_percent |> 
         # remove q0 baseline
         filter(source != "q0"), 
       aes(x = source, y = percent)) +
  geom_col(fill = color) +
  geom_text(aes(label = paste0(round(percent*100, 1), "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  labs(
    title = "Attrition",
    x = "Time Point",
    y = "Share of participants"
  ) +
  plot_theme +
  facet_wrap(~promo)
```

```{r}
#| label: fig-attrition-norupture
#| fig-cap: "Number of volunteers per survey time point,  **excluding** ruptures. Volunteers who appear under 'q0' have participated in the program but have not even filled out the first questionnaire (q1). Note that in the percentage plot, the percentages are relative to all volunteers from the respective promo."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

# ABSOLUTE NUMBERS

# Prepare data: Count unique participants per source
attrition_data <- combined |> 
  filter(rupture == "no_rupture") |> 
  group_by(promo, source) |> 
  summarise(n_participants = n_distinct(id_jeune)) |> 
  # remove the programmes (since it is not a survey time point)
  filter(source != "programmes") 


# Plot attrition trend across sources
ggplot(attrition_data, aes(x = source, y = n_participants)) +
geom_col() +
  geom_text(aes(label = n_participants), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  theme_minimal() +
  labs(
    title = "Survey fatigue (ruptures excluded)",
    x = "Time Point",
    y = "Number of Participants"
  ) + 
  plot_theme +
  facet_wrap(~promo)

# PERCENTAGES

# Step 1: Get baseline (q0 + q1) counts per promo
baseline_counts <- combined |>
  filter(rupture == "no_rupture") |> 
  filter(source == "q0" | source == "q1") |>
  group_by(promo) |>
  summarise(baseline_n = n_distinct(id_jeune), .groups = "drop")

# Step 2: Count participants per source and promo
attrition_percent <- combined |>
  filter(rupture == "no_rupture") |> 
  group_by(promo, source) |>
  summarise(n_participants = n_distinct(id_jeune), .groups = "drop") |>
  filter(source != "programmes") |> 
  left_join(baseline_counts, by = "promo") |>
  mutate(percent = n_participants / baseline_n)

# Step 3: Plot percentages relative to q0 and q1 

color <- wes_palette("Moonrise2")[3]

ggplot(attrition_percent |> 
         # remove q0 baseline
         filter(source != "q0"), 
       aes(x = source, y = percent)) +
  geom_col(fill = color) +
  geom_text(aes(label = paste0(round(percent*100, 1), "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  labs(
    title = "Survey fatigue (ruptures excluded)",
    x = "Time Point",
    y = "Share of participants"
  ) +
  plot_theme +
  facet_wrap(~promo)
```

## Voting {#sec-vote}

In this section, we look at how volunteers have changed regarding their voting behavior. Voting behavior was measured with the question: "Avez-vous voté lors des dernières élections (locales ou nationales) ?", which has been asked at time points q1 and q2. @fig-vote_derniers_elections-overview shows that, averaged across all cohorts and time points, the majority of volunteers reports having voted.

```{r}
#| label: fig-vote_derniers_elections-overview
#| fig-cap: |
#|   Distribution of whether volunteers reported having voted or not during the last elections, averaged across time points and cohorts.
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

vote_plot <- combined |> 
  drop_na(vote_derniers_elections) |> 
  mutate(source = ifelse(source %in% c("q1", "q0"), "q0/q1", source)) |> mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  mutate(across(vote_derniers_elections, ~ factor(., levels = c("Pas sur les listes", "Non", "Oui")))) |> 
  group_by(vote_derniers_elections) |> 
  summarize(n_volunteers = n_distinct(id_jeune)) |> 
  ungroup() |> 
  mutate(share = n_volunteers/sum(n_volunteers)) 


ggplot(vote_plot, 
       aes(x = vote_derniers_elections, y = n_volunteers, fill = vote_derniers_elections)) +
  geom_col(position = position_dodge(width = 0.9)) +
  scale_fill_manual(values = wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]) +
  geom_text(aes(label = n_volunteers),
            position = position_dodge(width = 0.9),
            vjust = -0.3,
            size = 4) +
  labs(
    x = "Vote",
    y = "Nombre de volontaires",
    fill = "Vote lors des dernières élections"
  ) +
  guides(fill = FALSE) +
  plot_theme 
  
ggplot(vote_plot, 
       aes(x = vote_derniers_elections, y = share, fill = vote_derniers_elections)) +
  geom_col(position = position_dodge(width = 0.9)) +
  geom_text(aes(label = scales::percent(share, accuracy = 1)), 
            vjust = -0.5, size = 4) +
scale_fill_manual(values = wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Vote",
    y = "Nombre de volontaires",
    fill = "Vote lors des dernières élections"
  ) +
  guides(fill = FALSE) +
  plot_theme 
```


In the following sections, we investigate how volunteers have changed in answering this question, throughout their service civique. For these analyses, we only consider those volunteers who have answered the question at both time points, q1 and q2. Changes towards "Yes" or "No" can have happened either from the respective other option, or from the third answer option: "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales", which is abbreviated in the plots below as "Pas sur les listes". We look at the different cohorts separately (promo 2020-21, @fig-vote_derniers_elections-2020; promo 2021-22, @fig-vote_derniers_elections-2021; 2022-23, @fig-vote_derniers_elections-2022; 2023-24, @fig-vote_derniers_elections-2023). 

The following sections reveal considerable differences between the cohorts. For example, in 2020-21 and 2021-22, many volunteers reported changes in voting behavior, but in opposite directions: In 2020-21, 24% of volunteers changed towards "No", outweighing those who changed to "Yes" (6%) by far. Inversely, in 2021-22, 35% of volunteers changed towards "Yes", while only 8% changed towards "No".

It is not clear why we observe these differences. One explanation might be that volunteers care more about national elections than local ones (or vice verse). If that is the case, we would expect changes in voting behavior to be dependent on whether there were national or local elections happening during the year of a cohort's service civique.

### Promo 2020-21

```{r}
#| label: fig-vote_derniers_elections-2020
#| fig-cap: "Promo 2020-21. Change in volunteers reporting whether they voted or not during the last elections, between Q1 and Q2. Note that this analysis considers only answers of volunteers who answered either yes or no at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2


vote_data <- combined %>%
  filter(promo == "20-21") |> 
  drop_na(vote_derniers_elections) |>
  # filter(vote_derniers_elections %in% c("Oui", "Non")) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui"))))

# run mcnemar test
#mcnemar.test(table(vote_data$vote_q1, vote_data$vote_q2))

# Prepare data for alluvial plot
vote_long <- vote_data |> 
  pivot_longer(cols = starts_with("vote_q"), names_to = "time", values_to = "vote") |> 
  mutate(time = recode(time, "vote_q1" = "q1", "vote_q2" = "q2"))


# Proportions
vote_long_prop <- vote_long |>
  group_by(time, vote) |>
  summarise(n = n(), .groups = "drop") |>
  group_by(time) |>
  mutate(prop = n / sum(n),
         # make positioning variable
         position = sum(n) - n,
         ) |>
  ungroup()

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(vote_long, 
       aes(x = time, stratum = vote, alluvium = id_jeune, fill = vote, label = vote)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme

vote_change_summary <- vote_data |>
  mutate(change = case_when(
    vote_q1 == vote_q2 ~ "Pas de changement",
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  )) |>
  drop_na(change) |> 
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(vote_change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    #"Pas de changement" = "#E1AF00",
    "Changé vers Non" = "#F21A00",
    "Changé vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    #title = "Changements individuels entre Q1 et Q2",
    x = NULL,
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

```{r}
# for a plot that takes into account NAs

# vote_long <- combined %>%
#   filter(source %in% c("q1", "q2")) |>
#   select(id_jeune, source, vote_derniers_elections) %>%
#   rename(time = source, 
#          vote = vote_derniers_elections) |> 
#     mutate(vote = ifelse(is.na(vote), "Pas de réponse", vote)
#            )
# 
# # Create alluvial plot
# ggplot(vote_long, 
#        aes(x = time, stratum = vote, alluvium = id_jeune, fill = vote, label = vote)) +
#   geom_flow(stat = "alluvium",  alpha = 0.7) +
#   geom_stratum() +
#   scale_x_discrete(expand = c(0.1, 0.1)) +
#   labs(
#     title = "Changements dans le vote entre Q1 et Q2",
#     x = "Temps",
#     y = "Nombre d'individus",
#     fill = "Vote"
#   ) +
#   plot_theme
```

```{r}
# for a statistical test
# action_data <- combined %>%
#   drop_na(action_individuelle_societe) |>
#   select(id_jeune, source, action_individuelle_societe) |> 
#   rename(time = source) |> 
#   # select individuals with observations in both
#   group_by(id_jeune) |>
#   filter(all(c("q1", "q3") %in% time)) |>
#   ungroup() |> 
#   # make factors
#   mutate(
#     action_individuelle_societe = factor(
#       action_individuelle_societe,
#       levels = c("Pas vraiment", "Non", "Oui")  # ref = Pas vraiment
#     ),
#     time = factor(time, levels = c("q1", "q3"))
#   )
# 
# # Multinomial logistic mixed model
# mod <- brm(
#   action_individuelle_societe ~ time + (1 | id_jeune),
#   data = action_data,
#   family = categorical(),
#   chains = 4, cores = 4, seed = 1234
# )
# 
# exp(fixef(mod))  # For point estimates
# 
# library(ggeffects)
# 
# preds <- ggpredict(mod, terms = "time")
# plot(preds) +
#   labs(title = "Effet du programme sur les réponses",
#        x = "Temps", y = "Probabilité prédite")
```

### Promo 2021-22

```{r}
#| label: fig-vote_derniers_elections-2021
#| fig-cap: "Promo 2021-22. Change in volunteers reporting whether they voted or not during the last elections, between Q1 and Q2. Note that this analysis considers only answers of volunteers who answered either yes or no at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2


vote_data <- combined %>%
  filter(promo == "21-22") |> 
  drop_na(vote_derniers_elections) |>
  # filter(vote_derniers_elections %in% c("Oui", "Non")) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui"))))

# run mcnemar test
#mcnemar.test(table(vote_data$vote_q1, vote_data$vote_q2))

# Prepare data for alluvial plot
vote_long <- vote_data |> 
  pivot_longer(cols = starts_with("vote_q"), names_to = "time", values_to = "vote") |> 
  mutate(time = recode(time, "vote_q1" = "q1", "vote_q2" = "q2"))


# Proportions
vote_long_prop <- vote_long |>
  group_by(time, vote) |>
  summarise(n = n(), .groups = "drop") |>
  group_by(time) |>
  mutate(prop = n / sum(n),
         # make positioning variable
         position = sum(n) - n,
         ) |>
  ungroup()

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(vote_long, 
       aes(x = time, stratum = vote, alluvium = id_jeune, fill = vote, label = vote)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme

vote_change_summary <- vote_data |>
  mutate(change = case_when(
    vote_q1 == vote_q2 ~ "Pas de changement",
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  )) |>
  drop_na(change) |> 
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(vote_change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    #"Pas de changement" = "#E1AF00",
    "Changé vers Non" = "#F21A00",
    "Changé vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    #title = "Changements individuels entre Q1 et Q2",
    x = NULL,
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

### Promo 2022-23

```{r}
#| label: fig-vote_derniers_elections-2022
#| fig-cap: "Promo 2022-23. Change in volunteers reporting whether they voted or not during the last elections, between Q1 and Q2. Note that this analysis considers only answers of volunteers who answered either yes or no at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2

vote_data <- combined %>%
  filter(promo == "22-23") |> 
  drop_na(vote_derniers_elections) |>
  # filter(vote_derniers_elections %in% c("Oui", "Non")) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui"))))

# run mcnemar test
#mcnemar.test(table(vote_data$vote_q1, vote_data$vote_q2))

# Prepare data for alluvial plot
vote_long <- vote_data |> 
  pivot_longer(cols = starts_with("vote_q"), names_to = "time", values_to = "vote") |> 
  mutate(time = recode(time, "vote_q1" = "q1", "vote_q2" = "q2"))


# Proportions
vote_long_prop <- vote_long |>
  group_by(time, vote) |>
  summarise(n = n(), .groups = "drop") |>
  group_by(time) |>
  mutate(prop = n / sum(n),
         # make positioning variable
         position = sum(n) - n,
         ) |>
  ungroup()

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(vote_long, 
       aes(x = time, stratum = vote, alluvium = id_jeune, fill = vote, label = vote)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme

vote_change_summary <- vote_data |>
  mutate(change = case_when(
    vote_q1 == vote_q2 ~ "Pas de changement",
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  )) |>
  drop_na(change) |> 
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(vote_change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    #"Pas de changement" = "#E1AF00",
    "Changé vers Non" = "#F21A00",
    "Changé vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    #title = "Changements individuels entre Q1 et Q2",
    x = NULL,
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

### Promo 2023-24

```{r}
#| label: fig-vote_derniers_elections-2023
#| fig-cap: "Promo 2023-24. Change in volunteers reporting whether they voted or not during the last elections, between Q1 and Q2. Note that this analysis considers only answers of volunteers who answered either yes or no at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2

vote_data <- combined %>%
  filter(promo == "23-24") |> 
  drop_na(vote_derniers_elections) |>
  # filter(vote_derniers_elections %in% c("Oui", "Non")) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui"))))

# run mcnemar test
#mcnemar.test(table(vote_data$vote_q1, vote_data$vote_q2))

# Prepare data for alluvial plot
vote_long <- vote_data |> 
  pivot_longer(cols = starts_with("vote_q"), names_to = "time", values_to = "vote") |> 
  mutate(time = recode(time, "vote_q1" = "q1", "vote_q2" = "q2"))


# Proportions
vote_long_prop <- vote_long |>
  group_by(time, vote) |>
  summarise(n = n(), .groups = "drop") |>
  group_by(time) |>
  mutate(prop = n / sum(n),
         # make positioning variable
         position = sum(n) - n,
         ) |>
  ungroup()

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(vote_long, 
       aes(x = time, stratum = vote, alluvium = id_jeune, fill = vote, label = vote)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme

vote_change_summary <- vote_data |>
  mutate(change = case_when(
    vote_q1 == vote_q2 ~ "Pas de changement",
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  )) |>
  drop_na(change) |> 
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(vote_change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    #"Pas de changement" = "#E1AF00",
    "Changé vers Non" = "#F21A00",
    "Changé vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    #title = "Changements individuels entre Q1 et Q2",
    x = NULL,
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

### Which demographic factors are associated with change of voting intentions? 

@fig-vote-change-model shows how different demographic variables predict changes in voting behavior. For this analysis, we look at all cohorts together. The outcome, changes in voting behavior, is binary (changed to no vs. changed to yes)^[I.e. ignoring all volunteers who did not change]. 

Plotted on the y-axis are the demographic variables, taken to predict change in voting behavior. For each categorical demographic variable, different levels are shown. For example, for the variable `age_category`, the plot shows three levels: `age_categorie18-20`, `age_categorie21-23`, `age_categorie24-30`. Each of these categories has an estimate (x-axis). These estimates are the results logistic regressions^[For each variable, a separate logistic regression has been run. The estimates from the logistic regression are exponantiated, so that the reported estimates can be interpreted as odds ratios (ORs).]. They indicate how being part of a certain category (e.g. being between 18 and 20 years old) predicts the chances of changing one's voting behavior. The estimates are "odds ratios", which can be conceived of as probabilities: An odds ratio of 1 means that this group has the same chance changing to "no" as changing to "yes". More than 1 means that this group is more likely to change to "yes". For example, an odds ratio of 2.0 means twice as likely. Less than 1 means that this group is more likely to change to "no". An odds ratio of 0.5 means half as likely. 

For each categorical variable, one category is chosen as the baseline (or reference) category. The odds ratios of all other categories are relative to that baseline. For example, for the variable `age_category`, the category "16-17" is not appearing in the graph, because it is the (invisible) baseline category. If the odds ratio for `age_category18–20` is 1.43, this means that 18 to 20 year-olds are more likely to change their vote towards "Yes", compared to 16 to 17 year-olds. More specifically, the odds of changing towards “Yes” among 18–20-year-olds are about 43% higher than among 16–17-year-olds. 

```{r}
# remove variables that don't make sense, i.e. the motive and the actual duration (obviously, the longer the duration, the less likely to have a rupture)
reduced_demographic_variables <- setdiff(demographic_variables, c("motif_rupture"))

# add the two non-demographic variables asked in q1
factors_for_model <- c(reduced_demographic_variables, "programme_cle")

# make vote data
vote_data <- combined %>%
  drop_na(vote_derniers_elections) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections,  all_of(factors_for_model)) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui")))) |> 
  mutate(change_vote = case_when(
    vote_q1 == vote_q2 ~ NA_character_,
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  ), 
  change_vote = factor(change_vote, levels = c("Changé vers Non", "Changé vers Oui"))
  ) 

# Fit one model per demographic variable
model_results <- factors_for_model  %>%
  map_dfr(function(var) {
    formula <- as.formula(glue::glue("change_vote ~ `{var}`"))
    
    model <- glm(formula, data = vote_data, family = "binomial")
    
    tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })

# check
# model_results
```

```{r}
#| label: fig-vote-change-model 
#| fig-cap: Effects of demographic factors on change in voting behavior. The outcome is binary (changed to no vs. changed to yes). The dots and their labels are the estimates of separate logistic regressions for each variable. The lines around the dots represent uncertainty in the estimates (95% confidence intervals). If these confidence intervals cross 1 (the dotted vertical line), the differences are not statistically significant, meaning we might observe them just by chance. The logarithmic scale (on the x-axis) is used so that in the visualization for the positive and negative odds ratio's to be symmetric (i.e. that 2 is as far away from 1 as is 0.5).

model_results <- model_results %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  scale_x_log10() +
  labs(
    x = "Odds Ratio (log scale)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

To understand this odds ratio, take @fig-vote_derniers_elections-age-absolute: it shows that among the 16 to 17 year-olds, 285 have changed towards "No", while only 238 have changed towards "Yes". That makes the odds of changing towards yes for the youngest age group, chosen as the baseline category in the model, `238:285 = ~0.84`. By contrast, among the 18 to 20 year-olds, the odds were `784:658 = ~1.19`. The odds ratio for the 18 to 20 year-olds compares their odds to those of the 16 to 17 year-olds `odds ratio = 1.19:0.84 = 1.4`.

@fig-vote_derniers_elections-age-percentages allows to compare the odds ratios to the percentages for the different age groups. Just like for absolute numbers, the odds ratios can be calculated from the percentages. For example, among the 16 to 17 year-olds, 13.8% have changed towards "No", while 11.5% have changed towards "Yes", making the odds of changing to "Yes", as above, `0.115:0.138 = ~0.83`^[Note that in this illustration, we obtain a slightly different value compared to 0.84 above due to rounding imprecision.]. Among the 18 to 20 year-olds, accordingly, the odds were, as above, `0.174:0.146 = ~1.19`, resulting in the same odds ratio of ~1.4. 

```{r}
#| label: fig-vote_derniers_elections-age-absolute
#| fig-cap: "Absolute numbers. Change in volunteers reporting whether they voted or not during the last elections, between Q1 and Q2, for the different age groups. Note that this analysis considers only answers of volunteers who answered either yes or no at *both* time points."

vote_data <- combined %>%
  drop_na(vote_derniers_elections) |>
  # filter(vote_derniers_elections %in% c("Oui", "Non")) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections, age_categorie) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui"))))

vote_change_summary <- vote_data |>
  mutate(change = case_when(
    vote_q1 == vote_q2 ~ "Pas de changement",
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  )) |>
  drop_na(change) |> 
  group_by(change, age_categorie) |> 
  summarize(n = n()) |>
  group_by(age_categorie) |> 
  mutate(prop = n / sum(n), 
         age_categorie = paste0("Age: ", age_categorie))

ggplot(vote_change_summary, aes(x = change, y = n, fill = change)) +
  geom_col() +
  geom_text(aes(label = n), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +
  scale_fill_manual(values = c(
    #"Pas de changement" = "#E1AF00",
    "Changé vers Non" = "#F21A00",
    "Changé vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    #title = "Changements individuels entre Q1 et Q2",
    x = NULL,
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme +
  facet_wrap(~age_categorie) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

```{r}
#| label: fig-vote_derniers_elections-age-percentages
#| fig-cap: "Percentages. Change in volunteers reporting whether they voted or not during the last elections, between Q1 and Q2, for the different age groups. Note that this analysis considers only answers of volunteers who answered either yes or no at *both* time points."

vote_data <- combined %>%
  drop_na(vote_derniers_elections) |>
  # filter(vote_derniers_elections %in% c("Oui", "Non")) |>
  mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  select(id_jeune, source, vote_derniers_elections, age_categorie) %>%
  pivot_wider(names_from = source, values_from = vote_derniers_elections, names_prefix = "vote_") %>%
  filter(!is.na(vote_q1) & !is.na(vote_q2)) %>%
  mutate(across(starts_with("vote_"), ~ factor(., levels = c("Pas sur les listes", "Non", "Oui"))))

vote_change_summary <- vote_data |>
  mutate(change = case_when(
    vote_q1 == vote_q2 ~ "Pas de changement",
    vote_q1 == "Oui" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Non" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    vote_q1 == "Pas sur les listes" & vote_q2 == "Non" ~ "Changé vers Non",
    vote_q1 == "Pas sur les listes" & vote_q2 == "Oui" ~ "Changé vers Oui", 
    TRUE ~ NA_character_
  )) |>
  drop_na(change) |> 
  group_by(change, age_categorie) |> 
  summarize(n = n()) |>
  group_by(age_categorie) |> 
  mutate(prop = n / sum(n), 
         age_categorie = paste0("Age: ", age_categorie))

ggplot(vote_change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 0.1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.2))) +
  scale_fill_manual(values = c(
    #"Pas de changement" = "#E1AF00",
    "Changé vers Non" = "#F21A00",
    "Changé vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    #title = "Changements individuels entre Q1 et Q2",
    x = NULL,
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme +
  facet_wrap(~age_categorie) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

On a side note, looking at the 16 to 17 age groups shows that some answers were erroneous. In France, the legal voting age is 18. Therefore, the 16 to 17 year olds, at least at the beginning of their service civique (q0/q1), have never been on a voting list before. However, as shown in @fig-vote_derniers_elections-youngest there are 443 volunteers who answered "No" at q0/q1 (which technically is true, but not the most specific answer option), and 20 who answered "Yes" (probably not reading the question carefully or accidentally clicking on the wrong response). It is unclear whether or how this could have affected our findings on changes in voting behavior. 

```{r}
#| label: fig-vote_derniers_elections-youngest
#| fig-cap: |
#|   Distribution of whether volunteers reported having voted or not during the last elections,
#|   at different time points, for the youngest age group (16–17 years old).
#|   All answers at q0/q1 that are not “Pas sur les listes” are not exactly correct.


combined |> 
  drop_na(vote_derniers_elections) |> 
  mutate(source = ifelse(source %in% c("q1", "q0"), "q0/q1", source)) |> mutate(vote_derniers_elections = case_when(
    vote_derniers_elections == "Vous n'aviez pas l'âge de voter ou vous n'étiez pas inscrit.e sur les listes électorales" ~ "Pas sur les listes", 
    TRUE ~ vote_derniers_elections
  )
  ) |> 
  group_by(age_categorie, vote_derniers_elections, source) |> 
  summarize(n_volunteers = n_distinct(id_jeune), .groups = "drop") |> 
  filter(age_categorie == "16-17") |> 
  ggplot(aes(x = source, y = n_volunteers, fill = vote_derniers_elections)) +
  geom_col(position = position_dodge(width = 0.9)) +
  scale_fill_manual(values = wes_palette("Darjeeling1")[c(1, 3, 5)]) +
  geom_text(aes(label = n_volunteers),
            position = position_dodge(width = 0.9),
            vjust = -0.3,
            size = 3) +
  facet_wrap(~age_categorie) +
  labs(
    x = "Source",
    y = "Nombre de volontaires",
    fill = "Vote lors des dernières élections"
  ) +
  plot_theme +
  theme(legend.position = "top")
```


## Individual action for society {#sec-individual-action}

In this section, we look at how volunteers have changed regarding their perception on whether their individual action can contribute to changing society. This was measured with the question: "En général, pensez-vous que votre action individuelle peut contribuer à changer la société ?", which has been asked at time points q1 and q3 We look at the different cohorts separately (promo 2020-21, @fig-action_individuelle_societe-2020; promo 2021-22, @fig-vote_derniers_elections-2021; 2022-23, @fig-vote_derniers_elections-2022; 2023-24, @fig-vote_derniers_elections-2023)^[Note that for the promo 2023-24, q3 is not yet available, and therefore the promo cannot be included here].

Descriptively, there is no clear positive or negative trend either. On average, across all cohorts, slightly more people are changing towards "No" or "Not really", compared to "Yes". 

### Promo 2020-21

```{r}
#| label: fig-action_individuelle_societe-2020
#| fig-cap: "Promo 2020-21. Change in volunteers reporting whether they think their individual action can contribute to changing society, between Q1 and Q3. Note that this analysis considers only answers of volunteers who answered at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2

# make wide format data to track change
action_data <- combined %>%
  filter(promo == "20-21") |> 
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe) %>%
  pivot_wider(names_from = source, values_from = action_individuelle_societe, names_prefix = "action_individuelle_") %>%
  filter(!is.na(action_individuelle_q1) & !is.na(action_individuelle_q3))


# Prepare data for alluvial plot
plot_data <- combined %>%
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe) |> 
  rename(time = source) |> 
  # select individuals with observations in both
  group_by(id_jeune) |>
  filter(all(c("q1", "q3") %in% time)) |>
  ungroup() |> 
  # make a factor
    mutate(action_individuelle_societe = factor(
    action_individuelle_societe,
    levels = c("Pas vraiment", "Non", "Oui")
  ))

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(plot_data, 
       aes(x = time, stratum = action_individuelle_societe, alluvium = id_jeune, fill = action_individuelle_societe, label = action_individuelle_societe)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme 

# make plot for change

change_summary <- action_data |>
  mutate(change = case_when(
    action_individuelle_q1 == action_individuelle_q3 ~ "Pas de changement",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment"
  )) |>
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    "vers Pas vraiment" = "#E1AF00",
    "vers Non" = "#F21A00",
    "vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    x = "Changé",
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

### Promo 2021-22

```{r}
#| label: fig-action_individuelle_societe-2021
#| fig-cap: "Promo 2021-22. Change in volunteers reporting whether they think their individual action can contribute to changing society, between Q1 and Q3. Note that this analysis considers only answers of volunteers who answered at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2

# make wide format data to track change
action_data <- combined %>%
  filter(promo == "21-22") |> 
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe) %>%
  pivot_wider(names_from = source, values_from = action_individuelle_societe, names_prefix = "action_individuelle_") %>%
  filter(!is.na(action_individuelle_q1) & !is.na(action_individuelle_q3))


# Prepare data for alluvial plot
plot_data <- combined %>%
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe) |> 
  rename(time = source) |> 
  # select individuals with observations in both
  group_by(id_jeune) |>
  filter(all(c("q1", "q3") %in% time)) |>
  ungroup() |> 
  # make a factor
    mutate(action_individuelle_societe = factor(
    action_individuelle_societe,
    levels = c("Pas vraiment", "Non", "Oui")
  ))

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(plot_data, 
       aes(x = time, stratum = action_individuelle_societe, alluvium = id_jeune, fill = action_individuelle_societe, label = action_individuelle_societe)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme 

# make plot for change

change_summary <- action_data |>
  mutate(change = case_when(
    action_individuelle_q1 == action_individuelle_q3 ~ "Pas de changement",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment"
  )) |>
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    "vers Pas vraiment" = "#E1AF00",
    "vers Non" = "#F21A00",
    "vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    x = "Changé",
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

### Promo 2022-23

```{r}
#| label: fig-action_individuelle_societe-2022
#| fig-cap: "Promo 2022-23. Change in volunteers reporting whether they think their individual action can contribute to changing society, between Q1 and Q3. Note that this analysis considers only answers of volunteers who answered at *both* time points."
#| fig-subcap:
#|   - "Alluvial plot"
#|   - "Percentages" 
#| layout-ncol: 2

# make wide format data to track change
action_data <- combined %>%
  filter(promo == "22-23") |> 
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe) %>%
  pivot_wider(names_from = source, values_from = action_individuelle_societe, names_prefix = "action_individuelle_") %>%
  filter(!is.na(action_individuelle_q1) & !is.na(action_individuelle_q3))


# Prepare data for alluvial plot
plot_data <- combined %>%
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe) |> 
  rename(time = source) |> 
  # select individuals with observations in both
  group_by(id_jeune) |>
  filter(all(c("q1", "q3") %in% time)) |>
  ungroup() |> 
  # make a factor
    mutate(action_individuelle_societe = factor(
    action_individuelle_societe,
    levels = c("Pas vraiment", "Non", "Oui")
  ))

pal <- wes_palette("Zissou1", 5, type = "discrete")[c(3, 5, 1)]

# Create alluvial plot
ggplot(plot_data, 
       aes(x = time, stratum = action_individuelle_societe, alluvium = id_jeune, fill = action_individuelle_societe, label = action_individuelle_societe)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", alpha = 0.7) +
  geom_stratum() +
  scale_fill_manual(values = pal) + 
  scale_x_discrete(expand = c(0.1, 0.1)) +
  labs(
    x = "Temps",
    y = "Nombre d'individus",
    fill = "Vote"
  ) +
  plot_theme 

# make plot for change

change_summary <- action_data |>
  mutate(change = case_when(
    action_individuelle_q1 == action_individuelle_q3 ~ "Pas de changement",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment"
  )) |>
  count(change) |>
  mutate(prop = n / sum(n))

ggplot(change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    "vers Pas vraiment" = "#E1AF00",
    "vers Non" = "#F21A00",
    "vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    x = "Changé",
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme
```

### Which demographic factors are associated with change in perceptions of one's individual contribution to society? 

@fig-action-change-model shows how different demographic variables predict changes in perceptions of one's individual contribution to society. For this analysis, we look at all cohorts together. The outcome, changes in perceptions of one's individual contribution to society, collapsed into a binary measure ("vers Non/Pas vraiment" vs. "vers Oui"). The plots can be interpreted as described above in the section on voting behavior (@sec-vote). An odds ratio of 1 means that a certain group has the same chance of changing to "Non/Pas vraiment" as changing to "Oui", compared to the baseline group. More than 1 means that this group is more likely to change to "Oui". Less than 1 means that this group is more likely to change to "Non/Pas vraiment". 

```{r}
# remove variables that don't make sense, i.e. the motive and the actual duration (obviously, the longer the duration, the less likely to have a rupture)
reduced_demographic_variables <- setdiff(demographic_variables, c("motif_rupture"))

# add the two non-demographic variables asked in q1
factors_for_model <- c(reduced_demographic_variables, "programme_cle")

# make action data
action_data <- combined %>%
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe, all_of(factors_for_model)) %>%
  pivot_wider(names_from = source, values_from = action_individuelle_societe, names_prefix = "action_individuelle_") %>%
  filter(!is.na(action_individuelle_q1) & !is.na(action_individuelle_q3)) |>
  # make a binary version of change
  mutate(change_action = case_when(
    action_individuelle_q1 == action_individuelle_q3 ~ NA_character_,
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Non" ~ "vers Non/Pas vraiment",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Non" ~ NA_character_,
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Pas vraiment" ~ "vers Non/Pas vraiment",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Pas vraiment" ~ NA_character_
  ), 
  change_action = factor(change_action, levels = c("vers Non/Pas vraiment", "vers Oui")
  )
  )


# Fit one model per demographic variable
model_results <- factors_for_model  %>%
  map_dfr(function(var) {
    formula <- as.formula(glue::glue("change_action ~ `{var}`"))
    
    model <- glm(formula, data = action_data, family = "binomial")
    
    tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })

# check
# model_results
```

```{r}
#| label: fig-action-change-model 
#| fig-cap: Effects of demographic factors on change in perceptions of how one's individual actions can contribute to society. The outcome is binary ("vers Non/Pas vraiment" vs. "vers Oui"). The dots and their labels are the estimates of separate logistic regressions for each variable. The lines around the dots represent uncertainty in the estimates (95% confidence intervals). If these confidence intervals cross 1 (the dotted vertical line), the differences are not statistically significant, meaning we might observe them just by chance. The logarithmic scale (on the x-axis) is used so that in the visualization for the positive and negative odds ratio's to be symmetric (i.e. that 2 is as far away from 1 as is 0.5).

model_results <- model_results %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  scale_x_log10() +
  scale_y_discrete(expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Odds Ratio (log scale)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal() 
```

The results suggests that volunteers from the "Relais" program are more likely to change towards "Yes", than volunteers from the "CŒUR" program. @fig-action_individuelle_societe-type zooms in on those findings.

```{r}
#| label: fig-action_individuelle_societe-type
#| fig-cap: "Change in volunteers reporting whether they think their individual action can contribute to changing society, between Q1 and Q3, depending on whether they were part of the 'CŒUR' or the 'Relais' program. Note that this analysis considers only answers of volunteers who answered at *both* time points."


# make wide format data to track change
action_data <- combined %>%
  drop_na(action_individuelle_societe) |>
  select(id_jeune, source, action_individuelle_societe, type_volontaire) %>%
  pivot_wider(names_from = source, values_from = action_individuelle_societe, names_prefix = "action_individuelle_") %>%
  filter(!is.na(action_individuelle_q1) & !is.na(action_individuelle_q3))


# make plot for change

change_summary <- action_data |>
  mutate(change = case_when(
    action_individuelle_q1 == action_individuelle_q3 ~ "Pas de changement",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Non" ~ "vers Non",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Pas vraiment" & action_individuelle_q3 == "Oui" ~ "vers Oui",
    action_individuelle_q1 == "Oui" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment",
    action_individuelle_q1 == "Non" & action_individuelle_q3 == "Pas vraiment" ~ "vers Pas vraiment"
  )) |>
  group_by(change, type_volontaire) |> 
  summarize(n = n()) |>
  group_by(type_volontaire) |>
  mutate(prop = n / sum(n))

ggplot(change_summary, aes(x = change, y = prop, fill = change)) +
  geom_col() +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            vjust = -0.5, size = 4) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), expand = expansion(mult = c(0, 0.1))) +
  scale_fill_manual(values = c(
    "vers Pas vraiment" = "#E1AF00",
    "vers Non" = "#F21A00",
    "vers Oui" = "#3B9AB2"
  )) +
  guides(fill = FALSE) +
  labs(
    x = "Changé",
    y = "Proportion",
    fill = NULL
  ) +
  plot_theme +
  facet_wrap(~type_volontaire) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

# Rupture {#sec-rupture}

```{r}
share_rupture <- combined |> 
  group_by(rupture) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = paste0(round(count / sum(count) * 100, 1), "%")) %>%
  split(.$rupture)
```

Not all volunteers work until the end of their contract. In fact, `r share_rupture$rupture$share` of volunteers have a "rupture", i.e. terminate the contract early (@fig-rupture-overview). There are various motives for ending one's contract early (@fig-rupture-motive). Not all of them are necessarily bad, e.g. "Embauche en CDD d'au moins 6 mois ou CDI", and some are outside of the influence of the volunteers, e.g. "Fin de validité du Titre de Séjour". 

```{r}
#| label: fig-rupture-overview
#| fig-cap: "Number of volunteers with a rupture (for various possible reasons, including positive ones, such as obtaining a work contract), pooled across all cohorts."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

combined |> 
  group_by(rupture) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = rupture, y = count, fill = rupture)) +
  geom_col() +
  scale_fill_viridis_d(option = "plasma") +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Rupture",
    y = "Number of volunteers"
  ) +
  plot_theme +
  guides(fill = FALSE)

combined |> 
  group_by(rupture) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = rupture, y = share, fill = rupture)) +
  geom_col() +
  scale_fill_viridis_d(option = "plasma") +
  geom_text(aes(label = paste0(share*100, "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Rupture",
    y = "Share of volunteers"
  ) +
  plot_theme +
  guides(fill = FALSE)
```


```{r}
#| label: fig-rupture-motive
#| fig-cap: "Prevalence of different rupture motives, pooled across all cohorts."

combined |> 
  group_by(motif_rupture, rupture_valence) |> 
  drop_na(motif_rupture) |> 
  summarise(n = n_distinct(id_jeune), .groups = "drop") |> 
  mutate(motif_rupture = fct_reorder(motif_rupture, n, .fun = sum)) |> 
  ggplot(aes(x = motif_rupture, y = n, fill = rupture_valence)) +
  geom_col(position = "dodge") +
  geom_text(aes(label = n), 
            position = position_dodge(width = 0.9),
            vjust = 0.3, hjust = -0.1, size = 3) +
  scale_fill_viridis_d(option = "plasma", end = 0.85) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = NULL,
    y = "Number of volunteers",
    fill = "Valence de la rupture"
  ) +
  labs(fill = NULL) +
  coord_flip() + 
  theme(legend.position = "top")
  
```


## Change in rupture

@fig-rupture illustrates change regarding how many volunteers have ended their contract early (rupture) by comparing the different promos. There are no clear trends with slightly more than 20% of volunteers having a rupture.

```{r}
#| label: fig-rupture
#| fig-cap: "Number of volunteers with a rupture (for various possible reasons, including positive ones, such as obtaining a work contract)."
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

combined |> 
  group_by(promo, rupture) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = rupture, y = count, fill = rupture)) +
  geom_col() +
  scale_fill_viridis_d(option = "plasma") +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Rupture",
    y = "Number of volunteers"
  ) +
  plot_theme +
  facet_wrap(~promo) +
  guides(fill = FALSE)

combined |> 
  group_by(promo, rupture) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = rupture, y = share, fill = rupture)) +
  geom_col() +
  scale_fill_viridis_d(option = "plasma") +
  geom_text(aes(label = paste0(share*100, "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Rupture",
    y = "Share of volunteers"
  ) +
  plot_theme +
  facet_wrap(~promo) +
  guides(fill = FALSE)
  
```

## What predicts whether volunteers end their contract early (rupture)?

For analyses on what predicts ruptures, we focus only on volunteers who ended their contract early for apparently *negative* reasons. We used a binary outcome measure (no negative rupture vs. negative rupture) and ran separate logistic regressions with demographic variables (@fig-rupture-model-demographic) a selection of other variables (@fig-rupture-model-other). 

An odds ratio of 1 means that a certain group has the same chance of having a rupture, compared to the baseline group. More than 1 means that this group is more likely to have a rupture. Less than 1 means that this group is less likely to have a rupture. 

```{r}
# remove variables that don't make sense, e.g., the motive and the actual duration (obviously, the longer the duration, the less likely to have a rupture)
reduced_demographic_variables <- setdiff(demographic_variables, c("rupture", "motif_rupture", "Duree_reelle_sc_mois"))

# add the two non-demographic variables asked in q1
factors_for_rupture <- c("perception_avenir_num", "action_individuelle_societe")

# make model data - we only want to have one rupture value per volunteer
rupture_data <- combined |>
  arrange(id_jeune, is.na(motif_rupture)) |>  # NA last
  group_by(id_jeune) |>
  slice(1) |>  # Keep first (i.e. non-NA if it exists)
  ungroup()

# Fit one model per demographic variable
model_results_other_variables <- factors_for_rupture %>%
  map_dfr(function(var) {
    df <- rupture_data %>%
      select(rupture_negative, !!sym(var)) %>%
      drop_na()
    
    # Only run if predictor has 2+ unique levels
    if (n_distinct(df[[var]]) < 2) {
      return(NULL)
    }
    
    formula <- as.formula(glue::glue("rupture_negative ~ `{var}`"))
    
    model <- glm(formula, data = df, family = "binomial")
    
    tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })

# check
# model_results_other_variables

# Fit one model per demographic variable
model_results_demographic_variables <- reduced_demographic_variables %>%
  map_dfr(function(var) {
    df <- rupture_data %>%
      select(rupture_negative, !!sym(var)) %>%
      drop_na()
    
    # Only run if predictor has 2+ unique levels
    if (n_distinct(df[[var]]) < 2) {
      return(NULL)
    }
    
    formula <- as.formula(glue::glue("rupture_negative ~ `{var}`"))
    
    model <- glm(formula, data = df, family = "binomial")
    
    tidy(model, exponentiate = TRUE, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })



# check
# model_results_demographic_variables
```

### Demographic factors

@fig-rupture-model-demographic reveals, for example, that older age groups or refugees are less likely to have a rupture, male volunteers and volunteers with a handicap are more likely. The odds ratios can be interpreted as in previous sections. To provide another example, take the variable whether volunteers were part of the "CŒUR" or of the "RELAIS" program (`type_volontaire`). The odds ratio is 0.9, meaning volunteers of the "RELAIS" program were less likely to have a rupture. More specifically, they only had 90% of the odds to breach their contract, compared to volunteers of the "CŒUR". 

To get a better sense of this, @fig-rupture-descriptive shows descriptive differences (in percentages) regarding ruputre for some demographic variables, including `type_volontaire`. The odds ratio can be obtained by dividing the odds of the "RELAIS" program (0.161:0.834 = 0.193) by the odds of the "CŒUR" program (0.181:0.819 = 0.221) program (0.193:0.221 = ~0.9)^[Note that there are slight differences with the reported odds ratio due to rounding errors.].

```{r}
#| label: fig-rupture-model-demographic 
#| fig-cap: Effects of demographic factors on negative ruptures. The outcome is binary (no negative rupture vs. negative rupture). The dots and their labels are the estimates of separate logistic regressions for each variable. The lines around the dots represent uncertainty in the estimates (95% confidence intervals). If these confidence intervals cross 1 (the dotted vertical line), the differences are not statistically significant, meaning we might observe them just by chance. The logarithmic scale (on the x-axis) is used so that in the visualization for the positive and negative odds ratio's to be symmetric (i.e. that 2 is as far away from 1 as is 0.5).


model_results <- model_results_demographic_variables %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  scale_x_log10() +
  labs(
    x = "Odds Ratio (log scale)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

```{r}
#| label: fig-rupture-descriptive 
#| fig-cap: Percentages of rupture for (allegedly) negative reasons for different groups, for different variables.

plot_variables <- c("age_categorie", "type_volontaire", "niveau_etudes", "sexe")

count_plot_data <- combined %>%
  mutate(across(all_of(plot_variables), as.character)) %>%
  pivot_longer(cols = all_of(plot_variables), names_to = "variable", values_to = "level") %>%
  drop_na(level) |> 
  group_by(variable, level, rupture_negative) |> 
  summarize(n = n_distinct(id_jeune)) |> 
  group_by(variable, level) %>%
  mutate(pct = n / sum(n) * 100) |> 
  ungroup()

ggplot(count_plot_data, aes(x = level, y = pct, fill = factor(rupture_negative))) +
  geom_col(position = position_dodge(width = 0.9)) +
  geom_text(
    aes(label = sprintf("%.1f%%", pct)),
    position = position_dodge(width = 0.9),
    vjust = -0.3,
    size = 3
  ) +
  scale_fill_viridis_d(option = "rocket", direction = -1) +
  facet_wrap(~ variable, scales = "free_x") +
  labs(
    x = NULL, y = "Share",
    fill = "Contract status",
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), breaks = seq(0,100, 20)) +
  coord_cartesian(ylim = c(0, max(count_plot_data$pct) * 1.2)) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

### Other factors

For non-demographic variables, investigating their relationship with rupture is not possible--simply because, by definition, for questions that have been only asked at "q2" and "q3", volunteers who had ended their contract early were not available anymore (see @tbl-rupture-candidates). Only for the two variables that have been asked at "q1": 

1. `perception_avenir_num` (Concernant votre avenir, êtes-vous...? 	Très confiant(e); Assez confiant(e); Peu confiant(e); Pas du tout confiant(e))^[Note `_num` in the variable name stands for 'numeric': we use a numeric version, from "Pas du tout confiant(e)" = 1, to "Très confiant(e)" = 4.]
2. `action_individuelle_societe` (En général, pensez-vous que votre action individuelle peut contribuer à changer la société ? 	Oui; Pas vraiment; Non)

@fig-rupture-model-other shows how these variables predict rupture. The variable `action_individuelle_societe` is categorical and can be interpreted like the demographic variables in the previous results: one category serves as the reference (omitted) category, and the reported odds ratios represent how the odds of rupture differ relative to that reference. The variable `perception_avenir_num` is numeric (on a scale from 1 to 4). For numeric predictors, the estimated odds ratio indicates how much the odds of rupture change, on average, for each one-unit increase on the scale. For example, the resulting estimate of 1.14 in @fig-rupture-model-other for `perception_avenir_num` means that, on average, a one point increase in confidence about one's future corresponds to 14% higher odds of rupture. In other words, the results suggest that, the more confident volunteers are about their future, the more likely they are to have a rupture, on average. However, @fig-rupture-perception_avenir zooms in on this finding and suggests that this average effect is mostly driven by those volunteers who are "very confident". 

```{r}
#| label: tbl-rupture-candidates
#| tbl-cap: Candidate variables to evaluating their association with rupture.

factors_for_rupture <- c("perception_avenir", 
                         "projet_avenir_concret", "action_individuelle_societe", 
                         "comparaison_utilite_autres", "fierte",
                         "confiance_en_soi", "confiance_avenir_personnel",
                         "impact_situation_actuelle", "integration")


combined |> 
  pivot_longer(all_of(factors_for_rupture), 
               names_to = "variable", 
               values_to = "value") |> 
  drop_na(value) |> 
  distinct(variable, source) |> 
  kbl()
```

```{r}
#| label: fig-rupture-model-other 
#| fig-cap: Effects of demographic factors on negative ruptures. The outcome is binary (no negative rupture vs. negative rupture). The dots and their labels are the estimates of separate logistic regressions for each variable. The lines around the dots represent uncertainty in the estimates (95% confidence intervals). If these confidence intervals cross 1 (the dotted vertical line), the differences are not statistically significant, meaning we might observe them just by chance. The logarithmic scale (on the x-axis) is used so that in the visualization for the positive and negative odds ratio's to be symmetric (i.e. that 2 is as far away from 1 as is 0.5).


model_results <- model_results_other_variables %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  scale_x_log10() +
  labs(
    x = "Odds Ratio (log scale)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```


```{r}
#| label: fig-rupture-perception_avenir
#| fig-cap: "Number of volunteers with a negative rupture, as a function of their confidence in their future."

combined |> 
  drop_na(perception_avenir) |> 
  group_by(rupture_negative, perception_avenir) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  group_by(perception_avenir) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = perception_avenir, y = share, fill = rupture_negative)) +
  geom_col(position = "dodge") +
  scale_fill_viridis_d(option = "rocket", begin = 0.2, end = 0.8) +
  geom_text(aes(label = paste0(share*100, "%")), 
            position = position_dodge(width = 0.9),,
            vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Perception Avenir",
    y = "Share of volunteers", 
    fill = "Rupture"
  ) +
  plot_theme 
  
```

# Satisfaction {#sec-satisfaction}

In this section, we look at satisfaction ("D'une manière générale, diriez-vous que votre Service Civique s'est déroulé de façon..." with levels 1, "pas du tout satisfaisainte", to 4, "très satisfaisante")^[In all analyses we treat this as a continuous variable]. As shown in @fig-satisfaction-descriptive, taking all cohorts together, the majority of volunteers thinks their experience is "très satisfaisant". 

```{r}
#| label: fig-satisfaction-descriptive
#| fig-cap: "Répartition des niveaux de satisfaction" 
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

combined |> 
  drop_na(satisfaction) |> 
  group_by(satisfaction) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = satisfaction, y = count)) +
  geom_col() +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Satisfaction",
    y = "Number of volunteers"
  ) +
  plot_theme +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))

color <- wes_palette("Moonrise3")[2]

combined |> 
  drop_na(satisfaction) |> 
  group_by(satisfaction) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = satisfaction, y = share)) +
  geom_col(fill = color) +
  geom_text(aes(label = paste0(share*100, "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Satisfaction",
    y = "Share of volunteers"
  ) +
  plot_theme +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

## Change in Satisfaction

@fig-satisfaction shows how satisfaction with the service civique has changed over time, between the different cohorts. The share of volunteers who are "very satisfied" has decreased over time, but the shares of those who are not or little satisfied have remained broadly stable. 

```{r}
#| label: fig-satisfaction
#| fig-cap: "Satisfaction between cohorts." 
#| 
combined <- combined |> 
  # make satisfaction a factor, also make a numeric version
  mutate(
    satisfaction = factor(
      satisfaction,
      levels = c(
        "Pas du tout satisfaisante",
        "Peu satisfaisante",
        "Assez satisfaisante",
        "Très satisfaisante"
      ),
      ordered = TRUE
    ),
    satisfaction_num = as.numeric(satisfaction)
  )

color <- wes_palette("Moonrise3")[2]

combined |> 
  drop_na(satisfaction) |> 
  count(promo, satisfaction) |> 
  group_by(promo) |> 
  mutate(prop = n / sum(n)) |> 
  ggplot(aes(x = satisfaction, y = prop)) +
  geom_col(position = "dodge", fill = color) +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            position = position_dodge(width = 0.8), 
            vjust = -0.5, size = 3) +
    scale_y_continuous(limits = c(0, NA), 
                       expand = expansion(mult = c(0, 0.1)),
                       labels = scales::percent_format(accuracy = 1)
                       ) +
  labs(
    x = "Satisfaction",
    y = "Proportion",
    fill = "Promo",
    title = "Répartition des niveaux de satisfaction par promo"
  ) +
  guides(fill = FALSE) + 
  facet_wrap(~promo) +  # Facet by promo
  plot_theme +
  theme(
    axis.text.x = element_text(angle = 15, hjust = 1)  # Rotate x-axis labels
  )

```

## What predicts whether volunteers are more satisfied ?

For analyses on what predicts satisfaction, we treat satisfaction as a continuous variable (from 1, "Pas du tout satisfaisante", to 4, "Très satisfaisante"). Because this outcome is continuous, we run linear regressions (and not logistic regressions, as before) on it. The results for demographic variables are displayed in @fig-rupture-model-demographic, for other variables in @fig-rupture-model-other. 

### Demographic factors

The results of the linear regressions are more straightforward to interpret. For categorical predictors (i.e., all demographic variables), the estimate is simply the average difference between the shown category and the (again, omitted) baseline category. For example, as shown with the variable `refugie`, refugees tend to be, on average, more satisfied by 0.2 points (on the 4-point satisfaction scale) than non-refugees.

```{r}
# non-demographic variables 
factors_for_satisfaction <- c(
  "perception_avenir_num",
  "action_individuelle_societe",
  "comparaison_utilite_autres",
  "fierte_num",
  "confiance_en_soi_num",
  "confiance_avenir_personnel_num",
  "impact_situation_actuelle"
)


# make model data - we only want to have one satisfaction value per volunteer
satisfaction_data <- combined |>
  arrange(id_jeune, is.na(satisfaction)) |>  # NA last
  group_by(id_jeune) |>
  slice(1) |>  # Keep first (i.e. non-NA if it exists)
  ungroup()

# Fit one model per other variable
model_results_other_variables <- factors_for_satisfaction %>%
  map_dfr(function(var) {
    df <- satisfaction_data %>%
      select(satisfaction_num, !!sym(var)) %>%
      drop_na()

    # Only run if predictor has 2+ unique levels
    if (n_distinct(df[[var]]) < 2) {
      return(NULL)
    }

    formula <- as.formula(glue::glue("satisfaction_num ~ `{var}`"))
    model <- lm(formula, data = df)

    tidy(model, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })

# Fit one model per demographic variable
model_results_demographic_variables <- demographic_variables %>%
  map_dfr(function(var) {
    df <- satisfaction_data %>%
      select(satisfaction_num, !!sym(var)) %>%
      drop_na()

    # Only run if predictor has 2+ unique levels
    if (n_distinct(df[[var]]) < 2) {
      return(NULL)
    }

    formula <- as.formula(glue::glue("satisfaction_num ~ `{var}`"))
    model <- lm(formula, data = df)

    tidy(model, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })


# check
# model_results_other_variables
```

```{r}
#| label: fig-satisfaction-demographic-variables 
#| fig-cap: Effects of demographic factors on satisfaction.


model_results <- model_results_demographic_variables %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate (on a scale from 1 to 4)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

### Other factors

Some of the non-demographic variables are numeric^[All variable names that end with `_num` have been treated as numeric for the present analyses], for example, `confiance_en_soi_num` (Pensez-vous avoir gagné en confiance en vous durant votre Service Civique ? 1 - Non, pas du tout; 2 - Non, pas vraiment; 3 - Oui, assez; 4 - Oui, beaucoup). 

For numeric variables, the estimates represent how much satisfaction increases or decreases with a one-unit increase in the predictor variable. For example, for `confiance_en_soi_num`, the estimate is 0.33. `confiance_en_soi_num` takes values on a 4-point scale (from 1, "Non, pas du tout", to 4, "Oui, beaucoup"). This means that, on average, a one unit increase in `confiance_en_soi_num` is associated with a 0.33 point in crease in satisfaction (4-point scale). 

```{r}
#| label: fig-satisfaction-other-variables 
#| fig-cap: Effects of other, non-demographic factors on satisfaction.

model_results <- model_results_other_variables %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate (on a scale from 1 to 4)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

# Confidence in one's future

In this section, we look at confidence in one's future (`perception_avenir`: "Concernant votre avenir, êtes-vous...?" with levels 1, "Pas du tout confiant.e", to 4, "Très confiant.e")^[In all analyses we treat this as a continuous variable]. As shown in @fig-perception-avenir-descriptive, taking all cohorts together, the majority of volunteers are "assez confiant.e". 

```{r}
#| label: fig-perception-avenir-descriptive
#| fig-cap: "Confidence in one's future, pooled across all cohorts." 
#| fig-subcap:
#|   - "(absolute numbers)"
#|   - "(percentages)" 
#| layout-ncol: 2

combined |> 
  drop_na(perception_avenir) |> 
  group_by(perception_avenir) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = perception_avenir, y = count)) +
  geom_col() +
  geom_text(aes(label = count), vjust = -0.5, size = 3) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Confidence in one's future",
    y = "Number of volunteers"
  ) +
  plot_theme +
  theme(axis.text.x = element_text(angle = 20, hjust = 1)) 

color <- wes_palette("Cavalcanti1")[4]

combined |> 
  drop_na(perception_avenir) |> 
  group_by(perception_avenir) |> 
  summarise(
    count = n_distinct(id_jeune)
  ) |> 
  mutate(share = round(count / sum(count), 3)
         ) |> 
  ggplot(aes(x = perception_avenir, y = share)) +
  geom_col(fill = color) +
  geom_text(aes(label = paste0(share*100, "%")), vjust = -0.5, size = 3) +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.1))) +
  labs(
    x = "Confidence in one's future",
    y = "Share of volunteers"
  ) +
  plot_theme +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))


```



## Change in confidence in one's future

@fig-perception_avenir shows how confidence in one's future has changed over time, between the different cohorts. The results are very stable, with a majority of volunteers being "assez confiant.e" in all cohorts.

```{r}
#| label: fig-perception_avenir
#| fig-cap: "Confidence in one's future, between cohorts." 

color <- wes_palette("Cavalcanti1")[4]

combined |> 
  drop_na(perception_avenir) |> 
  group_by(perception_avenir, promo) |> 
  summarise(n = n_distinct(id_jeune)) |> 
  group_by(promo) |> 
  mutate(prop = n / sum(n)) |> 
  ggplot(aes(x = perception_avenir, y = prop)) +
  geom_col(position = "dodge", fill = color) +
  geom_text(aes(label = scales::percent(prop, accuracy = 1)), 
            position = position_dodge(width = 0.8), 
            vjust = -0.5, size = 3) +
    scale_y_continuous(limits = c(0, NA), 
                       expand = expansion(mult = c(0, 0.1)),
                       labels = scales::percent_format(accuracy = 1)
                       ) +
  scale_fill_viridis_d(option = "plasma") +
  scale_color_viridis_d(option = "C", end = 0.85) +
  labs(
    x = "Perceptions of one's future",
    y = "Proportion"
  ) +
  plot_theme  + 
  facet_wrap(~promo) +  # Facet by promo
  plot_theme +
  theme(
    axis.text.x = element_text(angle = 15, hjust = 1)  # Rotate x-axis labels
  )

```


## What predicts whether volunteers are more confident in their future ? {#sec-perception-avenir}

As for satisfaction above, for analyses on what predicts confident in their future, we treat it as a continuous variable (1, "Pas du tout confiant.e", to 4, "Très confiant.e"). As for satisfaction, because this outcome is continuous, we run linear regressions on it. The results for demographic variables are displayed in @fig-perception-avenir-demographic-variables, for other variables in @fig-perception-avenir-other-variables. 

### Demographic factors

The results suggest that, compared to (the omitted category of 16 to 17 year-olds), 18 to 20 as well as 21 to 23 year-olds are slightly less confident, while 24 to 30 year olds are slightly more confident. Refugees are considerably more competent (0.45, on the 4-point scale) than non-refugees. Male volunteers are also more likely to be confident about their future (0.21), as are volunteers in the "Relais" program (0.13, compared to the "Coeur" program). 

```{r}
# non-demographic variables 
factors_for_perception_avenir <- c(
  "satisfaction_num",
  "action_individuelle_societe",
  "comparaison_utilite_autres",
  "fierte_num",
  "confiance_en_soi_num",
  "confiance_avenir_personnel_num",
  "impact_situation_actuelle"
)


# make model data - we only want to have one satisfaction value per volunteer
perception_avenir_data <- combined |>
  arrange(id_jeune, is.na(perception_avenir)) |>  # NA last
  group_by(id_jeune) |>
  slice(1) |>  # Keep first (i.e. non-NA if it exists)
  ungroup()

# Fit one model per other variable
model_results_other_variables <- factors_for_perception_avenir %>%
  map_dfr(function(var) {
    df <- perception_avenir_data %>%
      select(perception_avenir_num, !!sym(var)) %>%
      drop_na()

    # Only run if predictor has 2+ unique levels
    if (n_distinct(df[[var]]) < 2) {
      return(NULL)
    }

    formula <- as.formula(glue::glue("perception_avenir_num ~ `{var}`"))
    model <- lm(formula, data = df)

    tidy(model, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })

# Fit one model per demographic variable
model_results_demographic_variables <- demographic_variables %>%
  map_dfr(function(var) {
    df <- perception_avenir_data %>%
      select(perception_avenir_num, !!sym(var)) %>%
      drop_na()

    # Only run if predictor has 2+ unique levels
    if (n_distinct(df[[var]]) < 2) {
      return(NULL)
    }

    formula <- as.formula(glue::glue("perception_avenir_num ~ `{var}`"))
    model <- lm(formula, data = df)

    tidy(model, conf.int = TRUE) %>%
      filter(term != "(Intercept)") %>%
      mutate(variable = var)
  })


# check
# model_results_other_variables
```

```{r}
#| label: fig-perception-avenir-demographic-variables 
#| fig-cap: Effects of demographic factors on confidence in one's future.


model_results <- model_results_demographic_variables %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate (on a scale from 1 to 4)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

### Other factors

The only other variable we consider here is `action_individuelle_societe` ("En général, pensez-vous que votre action individuelle peut contribuer à changer la société ?" Oui; Pas vraiment; Non). @fig-perception-avenir-other-variables shows that volunteers who do not think that they can individually contribute to changing society (the omitted baseline category) are the least confident about their future: both volunteers who are slightly less pessimistic (having answered "Not really") and volunteers think they can contribute (having answered "Yes) are more likely to be confident, with those having answered "Yes" being most likely.

```{r}
#| label: fig-perception-avenir-other-variables 
#| fig-cap: Effects of other, non-demographic factors on confidence in one's future.

model_results <- model_results_other_variables %>%
  mutate(
    label = round(estimate, digits = 2)
  )

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate (on a scale from 1 to 4)",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

# Differences between programs {#sec-programs}

This section looks at how demographics of volunteers differe between programs. 

```{r}
program_count <- combined |> 
  drop_na(programme_1, programme_grouped, programme_cle) |> 
  summarize(n_programs = n_distinct(programme_1), 
            n_program_categories = n_distinct(programme_grouped),
            n_key_programs = n_distinct(programme_cle))

key_programs <- combined |>
  drop_na(programme_cle) |>
  distinct(programme_cle) |>
  pull(programme_cle) |>
  unique() |>
  paste(collapse = "; ")
```

```{r}
# define non-demographic variables to include in comparison
factors_for_program_comparison <- c(
  "satisfaction_num",
  "perception_avenir_num",
  "action_individuelle_societe",
  "comparaison_utilite_autres",
  "fierte_num",
  "confiance_en_soi_num",
  "confiance_avenir_personnel_num",
  "impact_situation_actuelle"
)
```

There are `r program_count$n_programs` different programs, which can be sorted into `r program_count$n_program_categories` different categories (see [Tables](tables.qmd)). Here, we only distinguish between `r program_count$n_key_programs` key program categories, namely: `r key_programs`. 

The following sections show, for each key program category, how the volunteers of that program differ compared to all the other key program categories combined, in terms of demographic variables. The results are expressed in odds ratios, which can be interpreted as above: If the odds ratio is *larger than 1*, then a certain group is *more likely* to be represented in the target key program category, compared to all other programs. For example, in @fig-solidarite-aidants-demographic-variables, there are more 18 to 20 year-olds (odds ratio = 1.18, compared to the omitted baseline, 16 to 17 year-olds) in the "Solidarité Aidants" program, than in the other programs, on average. If the odds ratio *is below 1*, this means that a certain group is *less likely* to be represented in the target key program category. For example, refugees are considerably less likely (odds ratio = 0.17, compared to the omitted baseline, non-refugees) to be in the "Solidarité Aidants" program, compared to all other programs, on average. 

## Solidarité Aidants {#sec-ecovolonterre}

```{r}
#| label: fig-solidarite-aidants-demographic-variables 
#| fig-cap: Differences in Solidarité Aidants vs. other programs along demographic factors.

# Run on Solidarité Aidants data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_solidarite_aidants_binary,
  predictor_sets = demographic_variables
) 

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

## Cinéma & Citoyenneté {#sec-cine}

Volunteers who work in cine-related projects tend to be older and more educated. Refugees are less likely to be cine volunteers. If there is a preliminary end to the contract, cine volunteers are more likely to do so because they were offered a CDD of less than 6 months. Refugees are less likely to be cine volunteers, and women, as well as people from urban areas are more likely.

```{r}
#| label: fig-cine-demographic-variables 
#| fig-cap: Differences in Cinéma & Citoyennetévs vs. other programs along demographic factors

# Run on Cinéma & Citoyenneté data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_cine_binary,
  predictor_sets = demographic_variables
) 


ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

## Booster {#sec-booster}

```{r}
#| label: fig-booster-demographic-variables 
#| fig-cap: Differences in Booster vs. other programs along demographic factors.

# Run on Booster data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_booster_binary,
  predictor_sets = demographic_variables
) 

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

## Ecovolonterre {#sec-ecovolonterre}

Ecovolonterres tend to be older (mostly in the 21 to 23 agegroup) and more educated than other volunteers. They tend to plan for longer volunteer programs. Ecovolonterres tend to be from more rural but also urban ares (compared to QVP).

```{r}
#| label: fig-ecovolonterre-demographic-variables 
#| fig-cap: Differences in Ecovolonterre vs. other programs along demographic factors.

# Run on Ecovolonterre data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_ecovolonterre_binary,
  predictor_sets = demographic_variables
) 

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

## Médiaterre {#sec-mediaterre}

```{r}
#| label: fig-mediaterre-demographic-variables 
#| fig-cap: Differences in Médiaterre vs. other programs along demographic factors.

# Run on Médiaterre data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_mediaterre_binary,
  predictor_sets = demographic_variables
) 

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

## ASM {#sec-asm}

```{r}
#| label: fig-asm-demographic-variables 
#| fig-cap: Differences in ASM vs. other programs along demographic factors.

# Run on Médiaterre data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_asm_binary,
  predictor_sets = demographic_variables
) 

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

## Solidarité Séniors {#sec-solidarite-seniors}

```{r}
#| label: fig-solidarite-seniors-demographic-variables 
#| fig-cap: Differences in Solidarité Séniors vs. other programs along demographic factors.

# Run on Médiaterre data
model_results <- run_program_models(
  data = combined,
  outcome_var = programme_solidarite_seniors_binary,
  predictor_sets = demographic_variables
) 

ggplot(model_results, aes(x = estimate, y = fct_rev(term), color = variable)) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  geom_point() +
  geom_text(
    aes(label = label),
    vjust = -0.4,  # just slightly to the right of the point
    size = 3,
    check_overlap = TRUE  # avoid overlapping labels
  ) +
  scale_x_log10() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
  scale_color_viridis_d(option = "plasma", end = 0.8) +
  labs(
    x = "Estimate",
    y = NULL
  ) +
  guides(color="none") +
  theme_minimal()
```

# Conclusion: Some methodological notes

This report can only provide snapshots into the extensive survey data that has been collected by Cité Unis. In general, the questionnaires could probably be shorter. Fewer questions would probably reduce attrition---if volunteers respond to a very long questionnaire at q1, they might not be motivated to again fill out another very long questionnaire at q2, let alone q3. Including fewer questions would probably also improve the quality of responses, as volunteers might get tired or bored with long questionnaires, thus clicking through very quickly and thoughtlessly at some point. Another option to improve quality in responses could be to add attention checks. However, since volunteers are not forced to take the survey, we can probably assume that those who take it are motivated to fill it out faithfully. 

Another lever for improvement is making the questionnaires at different time points more similar. Asking the same questions at all the different time points allow to track how individual volunteers change throughout their service civique (as in @sec-within-change). 

On a minor note, it might be more interesting to ask volunteers about their voting intentions, rather than their past voting behavior. There is reason to believe that some volunteers do not answer the current question on past behavior as intended (@fig-vote_derniers_elections-youngest). Also, observing change regarding past voting behavior is very dependend on whether elecitons happen to take place for a particular cohort during their year of service civique. 



